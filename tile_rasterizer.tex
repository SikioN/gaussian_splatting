\section{Быстрый дифференцируемый растеризатор для Гауссиан}
\label{sec:tile-raster}

Наши цели заключаются в обеспечении быстрого общего рендеринга и быстрой сортировки, чтобы позволить приближенное $\alpha$-смешивание — включая для анизотропных сплатов — и избежать жестких ограничений на количество сплатов, которые могут получать градиенты, как это существует в предыдущих работах~\cite{Lassner_2021_CVPR}.

Для достижения этих целей мы разработали тайловый растеризатор для Гауссиан, вдохновленный недавними подходами программного растеризатора~\cite{Lassner_2021_CVPR}, который позволяет предварительно сортировать примитивы для всего изображения сразу, избегая затрат на сортировку для каждого пикселя, что замедляло предыдущие решения с $\alpha$-смешиванием~\cite{kopanas21,kopanas22}. Наш быстрый растеризатор позволяет эффективно выполнять обратное распространение ошибки по произвольному числу смешанных Гауссиан с низким дополнительным потреблением памяти, требуя только постоянные накладные расходы на пиксель.
Наш конвейер растеризации полностью дифференцируем, и после проекции в 2D (Раздел~\ref{sec:3d-splats}) он может растеризовать анизотропные сплаты, аналогично предыдущим методам 2D сплаттинга~\cite{kopanas21}.

Наш метод начинается с разделения экрана на тайлы размером 16$\times$16, а затем переходит к отсечению 3D Гауссиан относительно пирамиды видимости и каждого тайла.
В частности, мы сохраняем только те Гауссианы, у которых интервал достоверности 99\% пересекает пирамиду видимости.
Кроме того, мы используем защитную полосу для тривиального отбраковывания Гауссиан в крайних положениях \ADDITION{(т.е., тех, чьи средние значения близки к ближней плоскости и сильно выходят за пределы пирамиды зрения)}, так как вычисление их проекции в 2D ковариацию было бы нестабильным.
Затем мы создаем экземпляры каждой Гауссианы в соответствии с количеством перекрываемых тайлов и присваиваем каждому экземпляру ключ, объединяющий глубину в пространстве просмотра и ID тайла. После этого мы сортируем Гауссианы на основе этих ключей, используя быструю GPU сортировку Radix~\cite{merrill2010revisiting}.
Обратите внимание, что здесь нет дополнительной сортировки точек на каждый пиксель, и смешивание выполняется на основе этой первоначальной сортировки. В результате, наше $\alpha$-смешивание может быть приближенным в некоторых конфигурациях.
Однако эти приближения становятся незначительными, когда \CORRECTION{точки}{сплаты} достигают размера отдельных пикселей.
Мы обнаружили, что этот выбор значительно повышает производительность обучения и рендеринга без создания заметных артефактов в сценах после сходимости.

После сортировки \CORRECTION{точек}{Гауссиан} мы формируем список для каждого тайла, определяя первый и последний элемент, отсортированный по глубине, который влияет на данный тайл. Для растеризации мы запускаем один блок потоков для каждого тайла. Каждый блок сначала совместно загружает пакеты \CORRECTION{точек}{Гауссиан} в разделяемую память, а затем, для данного пикселя, накапливает значения цвета и $\alpha$, проходя списки спереди назад, тем самым максимально увеличивая параллелизм как для загрузки/разделения данных, так и для их обработки.
Когда достигается целевое значение насыщения $\alpha$ в пикселе, соответствующий поток останавливается. С регулярными интервалами потоки в тайле проверяются, и обработка всего тайла завершается, когда все пиксели насыщаются (т.е., $\alpha$ становится равным 1). %
Детали сортировки и высокоуровневый обзор всего процесса растеризации представлены в Приложении~\ref{app:raster}.

Во время растеризации насыщение $\alpha$ является единственным критерием остановки. В отличие от предыдущих работ, мы не ограничиваем количество примитивов, участвующих в смешивании, которые получают обновления градиента. Мы применяем это свойство, чтобы позволить нашему подходу обрабатывать сцены с произвольной и изменяющейся глубиной сложности и точно обучать их, не прибегая к настройке гиперпараметров, специфичных для сцены.
Во время обратного прохода нам необходимо восстановить полную последовательность смешанных точек для каждого пикселя в прямом проходе. Одним из решений могло бы быть хранение произвольно длинных списков смешанных точек для каждого пикселя в глобальной памяти~\cite{kopanas21}. Чтобы избежать накладных расходов на динамическое управление памятью, мы выбираем повторное прохождение списков для каждого тайла; мы можем повторно использовать отсортированный массив Гауссиан и диапазоны тайлов из прямого прохода. Чтобы облегчить вычисление градиентов, мы теперь проходим их сзади наперёд.

Прохождение начинается с последней точки, которая оказала влияние на любой пиксель в тайле, и загрузка точек в разделяемую память снова происходит совместно. Кроме того, каждый пиксель будет проводить (дорогостоящее) тестирование наложения и обработку точек только если их \CORRECTION{индекс}{глубина} меньше или равна \CORRECTION{индексу}{глубине} последней точки, которая внесла вклад в его цвет во время прямого прохода.
Вычисление градиентов, описанных в Разделе~\ref{sec:3d-splats}, требует накопленных значений непрозрачности на каждом шаге во время исходного процесса смешивания.
\CORRECTION{Вместо хранения списка постепенно уменьшающихся значений непрозрачности во время прямого прохода, мы восстанавливаем эти значения из прямого прохода.}{Вместо обхода явного списка постепенно уменьшающихся значений непрозрачности в обратном проходе, мы можем восстановить эти промежуточные значения непрозрачности, сохраняя только общую накопленную непрозрачность в конце прямого прохода.}
В частности, каждая точка сохраняет окончательное накопленное значение непрозрачности $\alpha$ в прямом процессе; мы делим это на $\alpha$ каждой точки в нашем обратном проходе, чтобы получить необходимые коэффициенты для вычисления градиентов.